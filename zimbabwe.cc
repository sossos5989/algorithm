#include <array>
#include <iostream>
#define fastIO cin.tie(0)->sync_with_stdio(0)
using namespace std;

// 0~9 에서 숫자의 개수를 센다 ..
// 2 짝수
// 3 각 자리수의 합이 3의 배수
// 4
// 5
// 6
// 7
// 8
// 9 각 자리수의 합이 9의 배수
// 10 0으로 끝남
// 다이나믹 어디서 적용할까
// 개수를 세는 방법은 간단하지.. ++
// 조건을 조건 1과 조건2로 나눈다고 가정하자.
// 조건1: 재배치된 수 e'가 주어진 수 e보다 입력이 작을 것
// 조건2: e' % m == 0
// 무식하게 접근해보면, 조건 1인 수를 모두 구하고, 그 수가 조건 2에 부합하는지
// 일일히 확인합니다. 여기서 count ++ 연산이 수행되겠죠. count연산이 몇번
// 실행될까요 ? 최악의 경우를 상정해봅시다. 입력으로 15자리수까지 입력
// 가능합니다. 998877665543210 이라는 수가 있으면 15!/32 .. 번 count++연산을
// 수행해야합니다. 이 연산은 아마 1000초가 넘을 것입니다.. 당연히 대책이
// 필요하겠죠?
// .. 생각해봅시다. 조건2를 일일히 체크하지 말고, 조건2에 부합하는 e'를 만들 수
// 있을까요? 가능합니다 ! 수에 대해 생각해봅시다. 2의 경우는 단순히 끝자리가
// 짝수면 되겠죠. 3은 특수하게 모든 자리 수가 3의 배수면 됩니다.(모듈러 연산)
// 등을 이용해서 20까지 조건2를 부합하는 e''를 만들면 됩니다 !
// 아예 2를 만들어서 조건 1에 부합하는ㅈ ㅣdp를 쓸 수도 있겟지만
// 조금 생각해보면, 앞자리 숫자 * 자릿수.. ex
// 생각해보면, 5194 % 7 = 0 <=> 194 % 7 = 7 - (5000 % 7)
// 근데 쓸데없는 연산이 많은거같은데 .. 보면 . 7 11 13 19 이런게 너무 문제임
// ㅇㅇ;
string e;
int m;

int count(int index, int mod, array<int, 10> left) {
    if (index < 0)
        return 0;
}

int main() {
    fastIO;
    int repeat;
    cin >> repeat;
    while (repeat-- > 0) {
        cin >> e >> m;
        array<int, 10> numList = {0};
        for (int i = 0; i < e.length(); i++) {
            numList[e[i] - '0']++;
        }

        for (int i = 0; i < numList.size(); i++) {
            cout << numList[i] << " ";
        }
    }
    return 0;
}